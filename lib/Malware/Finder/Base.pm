package Malware::Finder::Base;

use strict;
use ThreadsPoolSafe;

use File::Copy qw(cp);
use Time::HiRes qw(gettimeofday tv_interval);

sub new{
    my ($class, %args) = @_;

    my $self = bless({
        debug => undef,
        f_infected => sub {@_},
        fix => undef,
        test => undef,
        extended_checks => 1,
        threshold_level => 11,
        workers => 2,

    }, $class);

    foreach (keys(%args)){
        $self->{$_} = $args{$_};
    } 

    define_accesors(keys(%$self));


    ThreadsPoolSafe->start(

        \&check_file,
        caller => $self,
        threads => $self->workers,
    
    );

    $self;
}


sub define_accesors {

    my @attrs = @_;

    no strict 'refs';
    
    foreach my $attribute (@attrs){

        *{$attribute} = sub {

            if(defined($_[1])){

                $_[0]->{$attribute} = $_[1];

                return $_[0];

            }
            else{

                return $_[0]->{$attribute};

            }
        };    
    
    }

}

sub DESTROY{}
sub EXTENSIONS {die("Abstract")};
sub CHECKS {die("Abstract")};

sub analyze_files {

    my ($self, $dir, $main) = @_;

    my @res;

    $dir =~ s/\/$//;
    
    if(opendir(my $d, $dir)) {

        my $str = join('|',$self->EXTENSIONS() );
        my $pattern = qr/\.($str)$/i;


        while(my $f = readdir($d)){

            next if($f =~/^\.+$/);

            push @res, $self->analyze_files("$dir/$f") if(-d "$dir/$f");

            push @res, "$dir/$f" if($f =~ $pattern && $self->launch_check_file($dir.'/'.$f));
        }

        closedir($d);
    }

    # wait for all threads to finish in the main loop
    if($main){
        ThreadsPoolSafe->finish();
    }

    @res;
}

sub launch_check_file {
    my($self, $file) = @_;
    
    ThreadsPoolSafe->sendWork($file);
}


sub check_file{
    my ($self,$file) = @_;

    print "--"x40, "\n","Checking $file\n" if($self->{debug});

    open(my $fh, $file) || die("Can't open file $file:$!");
    my $data;
    {
       $/ = undef;
       $data = <$fh>;
    }
    close($fh);
    
    my $fixed = undef;
    my $punctuation = 0;
    my @matches;
    
    my $t0 = [gettimeofday];
    foreach my $p ($self->CHECKS()){
        next if($p->{extended_check} && !$self->{extended_checks});
        
        print "Executing check: ".$p->{msg}."\n" if($self->{debug});
        
        if($p->{f_detect}->(\$data)){
        
            $punctuation += $p->{points};
            print "$file match check ".$p->{msg}." (points=$p->{points})\n" if($self->{debug});
            print ">>".$p->{msg_out}->()."<<\n" if($self->{debug} && exists($p->{msg_out}));
            push @matches, $p;

        }
    }
    printf "Checks time:%.3fs\n", tv_interval($t0) if($self->{debug});

    print "Comparing $punctuation with ".$self->threshold_level."\n" if($self->{debug});
    return undef unless($punctuation >= $self->threshold_level);
    
    $self->{f_infected}->($file,$punctuation);


    if($self->{fix}){
        foreach my $match (@matches){
            if(defined($match->{f_fix})){
                $fixed += ($match->{f_fix}->(\$data));
            }
        }
        
        unless($fixed){
            print "$file can't be fixed\n";
        }
        
        if($self->{test}){
            print $data;
        }
        else{
            cp($file, $file.'.fmwbkp');
            open my $fh, '>', $file;
            print $fh $data;
            close $fh;
            chmod(0644, $file);
        }
    }
    
    return 1;
}

1;
