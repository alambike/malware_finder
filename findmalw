#!/usr/bin/env perl
package MalwareFinder;
use strict;
use File::Copy qw(cp);

sub new{
    my ($class, %args) = @_;

    my $self = bless({
        debug => undef,
        f_infected => sub {@_},
        current_file => '',
        current_check => undef,
        fix => undef,
        test => undef,
        extended_checks => 1,
        threshold_level => 11,
    }, $class);

    foreach (keys(%args)){
        $self->{$_} = $args{$_};
    } 

    define_accesors(keys(%$self));

    $self;
}


sub define_accesors {

    my @attrs = @_;

    no strict 'refs';
    
    foreach my $attribute (@attrs){

        *{$attribute} = sub {

            if(defined($_[1])){

                $_[0]->{$attribute} = $_[1];

                return $_[0];

            }
            else{

                return $_[0]->{$attribute};

            }
        };    
    
    }

}

sub DESTROY{}
sub EXTENSIONS {die("Abstract")};
sub CHECKS {die("Abstract")};

sub analyze_files {

    my ($self, $dir) = @_;

    $dir =~ s/\/$//;
    opendir(my $d, $dir) || die("Error opening $dir: $!");

    my $str = join('|',$self->EXTENSIONS() );
    my $pattern = qr/\.($str)$/i;

    my @res;

    while(my $f = readdir($d)){

        next if($f =~/^\.+$/);

        push @res, $self->analyze_files("$dir/$f") if(-d "$dir/$f");

        push @res, "$dir/$f" if($f =~ $pattern && $self->check_file($dir.'/'.$f));
    }

    closedir($d);

    @res;
}

sub check_file{
    my $self = $_[0];

    my $file = $_[1];

    $self->current_file($file);

    print "--"x40, "\n","Checking $file\n" if($self->{debug});

    open(my $fh, $file) || die("Can't open file $file:$!");
    my $data;
    {
       $/ = undef;
       $data = <$fh>;
    }
    close($fh);
    
    my $fixed = undef;
    my $punctuation = 0;
    my @matches;
    
    foreach my $p ($self->CHECKS()){
        next if($p->{extended_check} && !$self->{extended_checks});
        
        print "Executing check: ".$p->{msg}."\n" if($self->{debug});
        
        $self->current_check($p);

        if($p->{f_detect}->(\$data)){
        
            $punctuation += $p->{points};
            print "$file match check ".$p->{msg}." (points=$p->{points})\n" if($self->{debug});
            print ">>".$p->{msg_out}->()."<<\n" if($self->{debug} && exists($p->{msg_out}));
            push @matches, $p;

        }
    }

    print "Comparing $punctuation with ".$self->threshold_level."\n" if($self->{debug});
    return undef unless($punctuation >= $self->threshold_level);
    
    $self->{f_infected}->($file,$punctuation);


    if($self->{fix}){
        foreach my $match (@matches){
            if(defined($match->{f_fix})){
                $fixed += ($match->{f_fix}->(\$data));
            }
        }
        
        unless($fixed){
            print "$file can't be fixed\n";
        }
        
        if($self->{test}){
            print $data;
        }
        else{
            cp($file, $file.'.fmwbkp');
            open my $fh, '>', $file;
            print $fh $data;
            close $fh;
            chmod(0644, $file);
        }
    }
    
    return 1;
}


package PHPMalwareFinder;
use parent -norequire, qw(MalwareFinder) ;
use strict;

my $MULTIPLE_OPEN_TAGS_IN_LINE = 

    qr/
        (?# Must start with an opening php tag followed by something non-space nor question mark )
        (?# ended with an finish tag)
        ^(\<\?php[^?\n]{300,}\?\>)

        (?# Followed by, maybe a separaton and another starting tag)
        [\ \t]*
        (\<(\?)?.+)
    /x;

my $CONDITIONAL_MALWARE = 

    qr|
        (?# http://blog.sucuri.net/2012/06/understanding-conditional-malware-ip-centric-variation.html )
        (?# Execute malware actions in function of user-agent and ip request procedence )
        
        (\<\?php.+\$user_agent_to_filter.+\$stop_ips_masks.+\$is_bot.+?\?\>)

    |xs;

my $BASE64_DATA = 
    qr{
        (?:([A-Za-z0-9+/]{4}\r?\n*){6,}
            (?:
                [A-Za-z0-9+/]{2} [AEIMQUYcgkosw048] = 
            |
                [A-Za-z0-9+/] [AQgw] == 
            )
        )[^=-\w]
    }x;

my $FALSE_POSITIVES= qr/
    (?:
        __icl_lang_names.+?English.+? |
        _JEXEC.+?PhocaGalleryRenderInfo.+?com_phocagallery |
        Coppermine.+?cornerleft.+?cornerright | 
        Coppermine.+?get_meta_album |
        vBulletin.+?attachment.+ | 
        Form\sMail\sScript.+?txt_wrong_html_template |
        cmsimple.+?addonsbydjot |
        t3lib_div.+?TYPO3 |
        moodlelib\.php.+?MOODLE_INTERNAL.+?get_config |
        Quinti\.net.+?recursos |
        AKEEBAENGINE.+?AKEEBA_SERVERKEY
        (?#

            admin_enqueue_scripts.+?import_epanel_javascript.+?importOptions | 
            scriptalicious | 
            dummy\.xml.+?\$dynamic_elements |
        )
    )
/xs;

my $GZINFLATE = qr/gzinflate/;
my $POST_AND_MAIL = qr/\<\?php.+(\$\_POST\[.+\bmail\(|\bmail\(.+\$\_POST\[)/s;
my $PACKED_FUNCTION = qr/function_exists.+pack\(/;
my $EVAL_BASE64_DECODE = qr/eval\s*(\(gzuncompress\s*)?\(\s*base64_decode/;
my $EVAL = qr/\<\?php.+\beval\s*\(/is;
my $BASE64_POST = qr/\<\?php.+base64_decode\s*\(\$\_POST\[/is;
my $POST_AND_EVAL = qr/\<\?php.+?(\$\_POST\[.+?eval\s*\(|eval\s*\(.+?\$\_POST\[)/is;
my $LD_PRELOAD = qr/LD_PRELOAD/;
my $PHP_OS = qr/PHP_OS\.chr/;
my $MULTIPLE_CHR_CALLS = qr/chr\(\d+\)/;
my $CHR_CALLS_LIMIT = 20;
my $LONG_LINE_WITH_EVAL_AND_TAGS = qr/^(\<\?(php)?.+eval\s*\(.+\?\>)/i;
my $LINE_TOO_LONG_LENGTH = 2000;
my $MALWARE_DOMAINS = qr/(familyy\-history\.com)/;
my $FUNCTION_OBFUSCATED = qr/function\s*l\_\_\d+\(/;
my $PHP_INLINE_CONTENT = 
    qr/
        \<\?(php)?
        (?<content>.+?)
        \?\>?
    /x;

my $PREG_REPLACE_EVAL = qr{
    (?: /\.\*/e | e/\*\./ )
}x;

my $BYTE_ESCAPED_STRING = qr/
    (?# min 6 hexadecimal chars)
    (?: \\x\d\d){6,}
/x;

sub CHECKS {

    my $data;

    ({
        msg => 'More than 1 php opening tag in same line',
        
        f_detect => sub {
            ${$_[0]} =~ $MULTIPLE_OPEN_TAGS_IN_LINE,
        },

        f_fix => sub {
            ${$_[0]} =~ s/$MULTIPLE_OPEN_TAGS_IN_LINE/$2/;
        },
        points => 10,
    },
    {
        msg => 'Long line with eval and tags',
        
        f_detect => sub {
            ${$_[0]} =~ $LONG_LINE_WITH_EVAL_AND_TAGS,
        },

        f_fix => sub {
            ${$_[0]} =~ s/$LONG_LINE_WITH_EVAL_AND_TAGS//;
        },
        points => 5,
    },

    {
        
        msg => 'Packed function detected',
        
        f_detect => sub {
            ${$_[0]} =~ $PACKED_FUNCTION
        },

        points => 10,
    },
    {
        msg => "Malware, remove!!",
        f_detect => sub {
            ${$_[0]} =~ $EVAL_BASE64_DECODE;
        },
        points => 20,
    },
    {
        msg => "Conditional malware, remove!",
        f_detect => sub {
            ${$_[0]} =~ $CONDITIONAL_MALWARE;
        },
        f_fix => sub {
            ${$_[0]} =~ s/$CONDITIONAL_MALWARE//;
        },
        points => 20,
    },

    {
        msg => "Sending requests to malware domains!!",
        f_detect => sub {
            ${$_[0]} =~ $MALWARE_DOMAINS;
        },
        points => 20,
    },

    {
        msg => "PHP Line too long!",
        extended_check => 1,
        
        f_detect => sub {
            foreach my $line (split(/\n+/, ${$_[0]})){
                if($line =~ $PHP_INLINE_CONTENT){
                    return 1 if (length($+{content}) > $LINE_TOO_LONG_LENGTH);
                }
            }
            return undef;
        },
        points => 10,
    },
    {
        msg => "Very few lines!",
        extended_check => 1,

        f_detect => sub {

            (scalar(split("\n", ${$_[0]})) <= 3)? 
                return 1: 
                return undef;
        },
        points => 5,
    },
    {
        msg => "base64_decode from POST data detected",
        extended_check => 1,
        f_detect => sub {
            ${$_[0]} =~ $BASE64_POST,
        
        },
        points => 5,
    },

    {
        msg => "eval post data detected",
        extended_check => 1,
        f_detect => sub {
            ${$_[0]} =~ $POST_AND_EVAL;
        },
        points => 7,
    },
    {
        msg => "LD_PRELOAD detected",
        extended_check => 1,
        f_detect => sub {
            ${$_[0]} =~ $LD_PRELOAD,
        
        },
        points => 20,
    },
    {
        msg => "PHP_OS detected",
        extended_check => 1,
        f_detect => sub {
            ${$_[0]} =~ $PHP_OS,
        
        },
        points => 5,
    },
    {
        msg => "A lot of chr calls (> $CHR_CALLS_LIMIT)!",
        extended_check => 1,
        f_detect => sub {
            my $count =()= ${$_[0]} =~ /$MULTIPLE_CHR_CALLS/g;
            ($count > $CHR_CALLS_LIMIT);
        
        },
        points => 5,
    },
    {
        msg => "base64 data detected",
        #msg_out => sub {$data},
        f_detect => sub {
            ${$_[0]} =~ $BASE64_DATA
        },
        points => 10,
    },
    {
        msg => "false positives",
        f_detect => sub {
            ${$_[0]} =~ $FALSE_POSITIVES
        },
        points => -10,
    },
    {
        msg => "gzinflate func detected",
        f_detect => sub {
            ${$_[0]} =~ $GZINFLATE
        },
        points => 5,
    },
    {
        msg => 'mail function and POST data detected',
        f_detect => sub {
            ${$_[0]} =~ $POST_AND_MAIL
        },
        points => 7,
    },
    {
        msg => 'function obfuscated detected',
        f_detect => sub {
            ${$_[0]} =~ $FUNCTION_OBFUSCATED
        },
        points => 5,
    },
    {
        msg => 'preg_replace_eval detected',
        f_detect => sub {
            ${$_[0]} =~ $PREG_REPLACE_EVAL
        },
        points => 10,
    },
    {
        msg => 'byte-escaped string detected',
        f_detect => sub {
            ${$_[0]} =~ $BYTE_ESCAPED_STRING
        },
        points => 5,
    },
    )
}


sub EXTENSIONS {
    qw(php html htm);
}


1;

package main;

use Cwd qw(abs_path);

sub BEGIN {
    my @partes = split /\//, abs_path($0);
    pop(@partes);
    push @INC, join('/', @partes);
}

use strict;
use Getopt::Std;
use IO::Handle;
use Data::Dumper;

our $VERSION = '1.35';
my $DEFAULT_THRESHOLD = 11;

autoflush STDOUT 1;

my $CONF = {};

load_cli_args();

my $PARSER_CLASS = uc($CONF->{lang}).'MalwareFinder';

my $parser = $PARSER_CLASS->new(
    f_infected => sub { 
        print 'File ['.$_[0].'] possibly infected ('.$_[1].")\n";
        print `ls -l $_[0]`;
    },
    fix => $CONF->{fix},
    test => $CONF->{test},
    threshold_level => $CONF->{threshold_level},
    debug => $CONF->{debug},
    extended_checks => 1
);

my $t_start = time();

if($CONF->{file}){

    print "Scanning '".$CONF->{file}."'\n";
	$parser->check_file($CONF->{file});
}

if($CONF->{dir}){

    print "Scanning '".$CONF->{dir}."'\n";
	my @infected = $parser->analyze_files($CONF->{dir});
}
my $t_end = time();

printf ("Analysis finished in %ds\n",$t_end-$t_start);

#################################################################

sub load_cli_args{
    my $conf = shift;

    # Mergeamos CONF cas opcions pasadas desde a linea de comandos
    my $opts = {};
    
    getopts("FTDt:d:l:f:", $opts) or HELP_MESSAGE();

    $CONF->{dir} = $opts->{d};
    $CONF->{file} = $opts->{f};
    HELP_MESSAGE() unless($CONF->{dir} || $CONF->{file});
    $CONF->{lang} = $opts->{l} || 'php';
    $CONF->{fix} = $opts->{F} || undef;
    $CONF->{test} = $opts->{T} || undef;
    $CONF->{debug} = $opts->{D} || undef;
    $CONF->{threshold_level} = $opts->{t} || $DEFAULT_THRESHOLD;
}

sub HELP_MESSAGE{
    
    my $msg = <<EOF  

    Usage: $0 -d <dir> -f <file> (-t <threshold_level) (-l <lang>) (-F) (-T) (-D) 
    
    -d <directory> : Directory to scan or
    -f <file> : File to scan (NEEDED)
    -t <threshold_level>: Minimum puntuaction to mark a file as infected (default: $DEFAULT_THRESHOLD)
    -F: Try to fix infection and clean file (backup created in same path <file>.fmwbkp)
    -T: Run in test mode
    -D: Run in debug mode

EOF
;
    print $msg;
    exit(0);

}

sub VERSION_MESSAGE {
    my $msg = <<EOF
    Version: $VERSION
EOF
;
    print $msg;
}

