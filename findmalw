#!/usr/bin/env perl

use Cwd qw(abs_path);

sub BEGIN {
    my @partes = split /\//, abs_path($0);
    pop(@partes);
    push @INC, join('/', @partes);
}

use strict;
use Getopt::Std;
use IO::Handle;

autoflush STDOUT 1;

my $CONF = {};

load_cli_args();

my $PARSER_CLASS = uc($CONF->{lang}).'MalwareFinder';
my $parser = $PARSER_CLASS->new(
    f_infected => sub { 
	print 'File '.$_[0]->current_file.' infected ('.$_[0]->current_pattern->{msg}.")\n",
    #my $file = $_[0]->current_file;
	#print `ls $file`;
    #print $file."\n" if ($_[0]->current_pattern->{msg} =~ /Malware/);
    },
    fix => $CONF->{fix},
    test => $CONF->{test},
);

my @infected = $parser->analyze_files($CONF->{dir});


#################################################################

sub load_cli_args{
    my $conf = shift;

    # Mergeamos CONF cas opcions pasadas desde a linea de comandos
    my $opts = {};
    getopts("Ftd:l:", $opts);

    $CONF->{dir} = $opts->{d} || '.' ;
    $CONF->{lang} = $opts->{l} || 'php';
    $CONF->{fix} = $opts->{F} || undef;
    $CONF->{test} = $opts->{t} || undef;
}

package MalwareFinder;

sub new{
    my ($class, %args) = @_;
    my $self = bless({
        debug => undef,
        f_infected => sub {@_},
        current_file => '',
        current_pattern => undef,
        fix => undef,
	test => undef,
    }, $_[0]);

    foreach (keys(%args)){
        $self->{$_} = $args{$_};
    } 

    $self;
}

sub AUTOLOAD{

    our $AUTOLOAD;

    if(defined($_[1])){
        $_[0]->{$AUTOLOAD} = $_[1];
    }
    else{
        $_[0]->{$AUTOLOAD};
    }
}

sub DESTROY{}
sub EXTENSIONS {die("Abstract")};
sub PATTERNS {die("Abstract")};

sub analyze_files {

    my ($self, $dir) = @_;

    $dir =~ s/\/$//;
    opendir(my $d, $dir) || die("Error opening $dir: $!");

    my $str = join('|',$self->EXTENSIONS() );
    my $pattern = qr/\.($str)$/i;

    my @res;

    while(my $f = readdir($d)){

        next if($f =~/^\.+$/);

        push @res, $self->analyze_files("$dir/$f") if(-d "$dir/$f");

        push @res, "$dir/$f" if($f =~ $pattern && $self->check_file($dir.'/'.$f));
    }

    closedir($d);

    @res;
}



package PHPMalwareFinder;
use parent -norequire, qw(MalwareFinder) ;
use File::Copy qw(cp);

sub PATTERNS {(
    {
        regexp => qr/^(\<\?php.+\?\>)(\<(\?)?.+)/,
        msg => 'More than 1 php opening tag in same line',
	fix_provided => 1,
    },
    {
        regexp => qr/function_exists.+pack\(/,
        msg => 'Packed function',
    },
    {
	regexp => qr/^\<\?php\s+eval\s*\(\s*base64_decode/,
	msg => "Malware, remove!!",
    }

)}


sub EXTENSIONS {
    qw(php html htm);
}

sub check_file{
    my $self = $_[0];

    my $file = $_[1];

    $self->current_file($file);

    print "Checking $file\n" if($self->{debug});

    open(my $fh, $file) || die("Can't open file $file:$!");
    my $data;
    {
       $/ = undef;
       $data = <$fh>;
    }
    close($fh);
    
    my $fixed = undef;
    
    foreach my $p ($self->PATTERNS){

	$self->current_pattern($p);
        if($data =~ $p->{regexp}){
	    $self->{f_infected}->($self);
            $data =~ s/$p->{regexp}/$2/;
	    $fixed = $p->{fix_provided};
        }
    }

    if($self->{fix}){

	next unless($fixed);

	if($self->{test}){
		print $data;
	}
	else{
		cp($file, $file.'.fmwbkp');
		open my $fh, '>', $file;
    		print $fh $data;
		close $fh;
		chmod(0644, $file);
	}
    }

    #open(my $fh, $file) || die("Can't open file $file:$!");
    #while(my $line = <$fh>){
    #    
    #    foreach my $p ($self->PATTERNS){
    #        $self->current_pattern($p);

    #        print "Testing line against ".$p->{regexp}."\n" if($self->{debug});

    #        if($line =~ $p->{regexp}){

    #    	$self->{f_infected}->($self);
    #    	
    #    	return 1;
    #            
    #        }
    #    }
    #}
    #close($fh);

    return undef;
}

